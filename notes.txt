const loopTime = 1;
const earthOrbitSpeed = 0.0001;
const moonOrbitRadius = 100;
const moonOrbitSpeed = 30;

const curve = new THREE.EllipseCurve(
    0,0,
    1000, 1150,
    0, 2*Math.PI,
);

const points = curve.getSpacedPoints(200)
const geometry = new THREE.BufferGeometry().setFromPoints(points)
const material = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.5 })
const orbit = new THREE.Line(geometry, material)
orbit.rotateX(-Math.PI/2)
scene.add(orbit)


const fakeEarthGeo = new THREE.SphereGeometry(50, 50, 50)
const fakeEarthMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
const fakeEarth = new THREE.Mesh(fakeEarthGeo, fakeEarthMaterial)

const fakeMoonGeo = new THREE.SphereGeometry(20, 20, 20)
const fakeMoonMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
const fakeMoon = new THREE.Mesh(fakeMoonGeo, fakeMoonMaterial)
const fakeMoonObj = new THREE.Object3D();
// fakeMoon.position.set(150, 0, 0);
fakeEarth.add(fakeMoonObj.add(fakeMoon));

scene.add(fakeEarth)


function animate() {
    const time = earthOrbitSpeed * Date.now();
    const t = (time % loopTime) / loopTime

    let p = curve .getPoint(t)
    console.log(p, t)

    fakeEarth.position.x = p.x;
    fakeEarth.position.z = p.y;

    fakeMoon.position.x = -Math.cos(time * moonOrbitSpeed) * moonOrbitRadius;
    fakeMoon.position.z = -Math.sin(time * moonOrbitSpeed) * moonOrbitRadius;
}